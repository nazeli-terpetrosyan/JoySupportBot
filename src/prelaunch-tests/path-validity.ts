import { StorytellerConfig } from '../core/models/chat-client/chat-client'
import ConvoModule, {
    ConvoModuleId,
} from '../core/models/convo-engine/convo-graph/convo-module'
import {
    ConvoSegmentPath,
    AbsoluteConvoSegmentPath,
} from '../core/models/convo-engine/convo-graph/convo-path'
import { convoSegmentPath } from '../core/util/make/unvalidated-type-constructors'
import UserChoice from '../core/models/convo-engine/convo-graph/user-choice'
import { ConvoLogicAction } from '../core/models/convo-engine/convo-graph/convo-logic'
import { concatArraysReducer } from '../core/util/util-functions'
import { ConvoSegmentId } from '../core/models/convo-engine/convo-graph/convo-segment'
import { safelyGetConvoSegment } from '../core/convo-engine/state-manager'
import { Either, tryCatch, fold } from 'fp-ts/lib/Either'
import log from '../core/util/logging'
import { Option, some, none } from 'fp-ts/lib/Option'
import * as _ from 'lodash'

type ConvoModulePath = ConvoModuleId[]

type PathAndModule = {
    path: ConvoModulePath
    module: ConvoModule
}

type PathAndInstantiation = {
    pathValue: ConvoSegmentPath
    pathInstantiation: ConvoSegmentPath
}

type LookupResult = {
    pathIsValid: boolean
}

type PathLookupResult = LookupResult & PathAndInstantiation

const allNestedModules: (
    rootModule: ConvoModule
) => Set<PathAndModule> = rootModule => {
    const visitedPathsAndModules: Set<PathAndModule> = new Set()
    const modulesToVisit: PathAndModule[] = [
        { path: [rootModule.id], module: rootModule },
    ]

    while (modulesToVisit.length > 0) {
        const currentPathAndModule = modulesToVisit.pop()
        if (currentPathAndModule === undefined) {
            throw new Error(
                `Unreachable null-check error in path validity test. This indicates a problem with the test`
            )
        }
        visitedPathsAndModules.add(currentPathAndModule)

        const {
            path: currentPath,
            module: currentModule,
        } = currentPathAndModule

        Object.values(currentModule.submodules).forEach(submodule => {
            const newPath = [...currentPath, submodule.id]
            modulesToVisit.push({
                path: newPath,
                module: submodule,
            })
        })
    }
    return visitedPathsAndModules
}

const pathFromActon: (
    action: ConvoLogicAction
) => ConvoSegmentPath[] = action => {
    switch (action.type) {
        case 'start-convo-segment':
            return [action.path]
        default:
            return []
    }
}

const allPathsFromActions: (
    actions: ConvoLogicAction[]
) => ConvoSegmentPath[] = actions => {
    return actions.map(pathFromActon).reduce(concatArraysReducer, [])
}

const allPathsFromChoice: (
    choice: UserChoice
) => ConvoSegmentPath[] = choice => {
    return choice.logic
        .map(logic => {
            // De-duplication here, because the `otherwise` case is auto generated by the logic constructor if no `if` statement is specified
            if (logic._compiledWithoutConditional) {
                return [...allPathsFromActions(logic.do)]
            } else {
                return [
                    ...allPathsFromActions(logic.do),
                    ...allPathsFromActions(logic.otherwise),
                ]
            }
        })
        .reduce(concatArraysReducer, [])
}

const allPathsFromChoices: (
    choices: UserChoice[]
) => ConvoSegmentPath[] = choices => {
    return choices.map(allPathsFromChoice).reduce(concatArraysReducer, [])
}

const convoSegmentPathConstructor: (
    parentModules: ConvoModulePath,
    id: ConvoSegmentId
) => ConvoSegmentPath = (parentModules, id) => ({
    parentModules,
    id,
})

// Does not consider nested paths
const allPathsFromModule: (
    pathAndModule: PathAndModule
) => PathAndInstantiation[] = pathAndModule => {
    return Object.values(pathAndModule.module.convoSegments)
        .map(convoSegment => {
            const pathValues = allPathsFromChoices(convoSegment.choices)
            return pathValues.map(pathValue => ({
                pathValue,
                pathInstantiation: convoSegmentPathConstructor(
                    pathAndModule.path,
                    convoSegment.id
                ),
            }))
        })
        .reduce(concatArraysReducer, [])
}

const allPathsFromModuleAndItsSubmodules: (
    rootModule: ConvoModule
) => PathAndInstantiation[] = rootModule => {
    const allModules = allNestedModules(rootModule)
    return Array.from(allModules)
        .map(allPathsFromModule)
        .reduce(concatArraysReducer, [])
}

const pathIsValid: (
    root: ConvoModule,
    currentPath: AbsoluteConvoSegmentPath,
    testPath: ConvoSegmentPath
) => boolean = (root, currentPath, testPath) => {
    return fold(
        error => false,
        value => true
    )(safelyGetConvoSegment(root, testPath, currentPath))
}

const pathLookupResultFromPathAndInstantiation: (
    rootModule: ConvoModule
) => (
    pathAndInstatiation: PathAndInstantiation
) => PathLookupResult = rootModule => pathAndInstatiation => ({
    ...pathAndInstatiation,
    pathIsValid: pathIsValid(
        rootModule,
        pathAndInstatiation.pathInstantiation as AbsoluteConvoSegmentPath,
        pathAndInstatiation.pathValue
    ),
})

export const allPathsAreValid: (
    config: StorytellerConfig
) => Option<Error> = config => {
    log.debug(`~~~~~> Checking that all module paths are valid`)
    const flatmapPathsAndConvoSegmentInstantiations = allPathsFromModuleAndItsSubmodules(
        config.rootModule
    )
    const pathLookupCurried = pathLookupResultFromPathAndInstantiation(
        config.rootModule
    )
    const lookupResults = flatmapPathsAndConvoSegmentInstantiations.map(
        pathLookupCurried
    )
    const invalidPaths = lookupResults.filter(
        lookupResult => !lookupResult.pathIsValid
    )
    const delimeter = `=======`
    if (invalidPaths.length > 0) {
        log.error(`The following paths are invalid!`)
        invalidPaths.forEach(invalidPath => {
            log.error(delimeter, `invalid path `, invalidPath.pathValue)
            log.debug(
                `For reference, this path is defined in the convo segment`,
                invalidPath.pathInstantiation
            )
        })
        return some(
            Error(
                `Invalid path in module definition! Please fix this before running the chatbot server.`
            )
        )
    } else {
        log.debug(`~~~~~> All paths are valid!`)
        return none
    }
}
